<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wikidot="http://www.wikidot.com/rss-namespace">

	<channel>
		<title>Hintjens</title>
		<link>http://hintjens.com</link>
		<description></description>
				<copyright></copyright>
		<lastBuildDate>Wed, 09 Oct 2019 09:28:29 +0000</lastBuildDate>
		
					<item>
				<guid>http://hintjens.com/blog:41</guid>
				<title>Licenses for Protocols</title>
				<link>http://hintjens.com/blog:41</link>
				<description>

&lt;p&gt;A few years back, when we set-up the &lt;a href=&quot;http://www.digistan.org&quot;&gt;Digital Standards Organization&lt;/a&gt;, one of our goals was to create a simpler framework for protocol development. At the time, licensing a protocol spec as open source was unheard of, and offensive to many people. Today it&#039;s just radical. In this article, I&#039;ll look at why and how to license a protocol spec.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613308&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Wed, 17 Apr 2013 13:51:44 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>A few years back, when we set-up the <a href="http://www.digistan.org">Digital Standards Organization</a>, one of our goals was to create a simpler framework for protocol development. At the time, licensing a protocol spec as open source was unheard of, and offensive to many people. Today it's just radical. In this article, I'll look at why and how to license a protocol spec.</p> <p>Most of the open standards we use are not licensed for remixing. That is, if you take the HTTP spec and try to make a new document based off it, and publish that, you are violating the IETF's copyright, and your modified spec will (I assume) be asked to disappear.</p> <p>In the old days, the thinking was that a standard has to be inviolate. There's a process for building it, and then we need a single standard. Forking a standard would be&#8230; bad.</p> <p>Then around 2007 we realized that if a standard ever became important (in a good or bad way) to someone's business, it was relatively easy for powerful, wealthy firms to simply take over the standards-making body, and thus take over the standards. We saw this happen with OOXML, where Microsoft effectively took over parts of ISO so it could push this thing through as an &quot;International Standard&quot;. Microsoft then did a similar move into OASIS so it could control the future of ODF, the competing standard.</p> <p>Anyone involved in standards-setting committees has seen the cost of the traditional process. The key question we had in Digistan was <em>how do we make standards development cheaper?</em> I used the term &quot;unprotocol&quot; to describe this cheap, community-built standard.</p> <p>Of course anyone can design and publish a protocol and say, &quot;He guys, here's my vision, any comments?&quot; How do you get real contributions from people willing to bet money on that?</p> <p>I argued at the time that developing standards was the same as writing software. You want people to compete and collaborate in the same way. Open knowledge. Blah blah, you know the story. My main argument was that forking was not bad, but essential. The right to fork was essential. It's the only guarantee an implementor has that if some unkind people with more time and money capture the standard process, they don't destroy your business. Paranoia? Maybe, but it happened to us with AMQP, which became a captive enterprise jelly fish. We lost a huge investment in OpenAMQ. Well, it freed us to make ZeroMQ but still&#8230; that should have happened as a smooth evolution of AMQP, not a reboot.</p> <p>Freedom to fork. This is the first, essential requirement of an unprotocol. Any open source license will give this freedom, BSD, MIT, X11, Apache, MPL, GPL. Also, a Creative Commons license like CC0.</p> <p>But it's not sufficient. Imagine if AMQP had been BSD or CC0. Now imagine it's successful and businesses start rolling out products based on it. They're competitors so they look for ways to gain advantage. One classic way is to build proprietary extensions. This happens so often it's ridiculous.</p> <p>If I'm a lawyer working for some evil corporation, say Microhat, or Redsoft, I'll tell my clients this: &quot;You make an extension of the standard that passes the conformance tests, but you make your extensions proprietary and you license them on your own terms.&quot;</p> <p>If I extend a CC0 or BSD protocol, my version of the protocol is by default proprietary. <em>The license does not extend to forks</em>. I can announce any licensing model I want on my extensions. For instance, &quot;You may only use this protocol on Tuesdays&quot;. Now, if I'm big and rich enough, I can force this on my users.</p> <p>Forks must be remixable. This is the second, essential requirement of an unprotocol. If you don't do this, your low-cost community is vulnerable to attack by well-funded competitors. Only the CC-SA and GPL provide this assurance.</p> <p>Further, as that lawyer, I tell my clients, &quot;Now please file a patent claim on these extensions and put a patent license into your support model. It doesn't matter if the patent gets granted. The claim will be enough to scare clients into paying.&quot;</p> <p>Paranoia? Maybe, but RedHat did this with AMQP: <a href="http://kirkwylie.blogspot.be/2009/03/red-hats-amqpxml-patent-press-release.html">patented a proprietary extension for XML routing</a>. Patents aren't just toxic to competition, they can scare people away from the whole standard itself.</p> <p>OK, it's true that anyone can file patents on protocols, but it's the firms that implement them who have the strongest incentive to patent around the edges. You do need to consider this threat.</p> <p>So, the last requirement is protection from patents. The GPLv3 has language that scares off patent lawyers. It's effective. and arguably the main reason Apple has invested so much in removing all GPLv3 products from its stacks and tool chains.</p> <p>Finally, how do you enforce interoperability when anyone can make forks? The answer is the same as in open source. You use a domain name and trademark and establish your processes under that brand. For instance, conformance tests, and contribution policy. People see the name, they know what they're getting.</p> <p>So in conclusion, my advice is to treat protocol licensing like network security. You try to guard against known attacks, you don't trust good intentions. It comes down to CC-BY-SA if you're not concerned about patents, and GPLv3 if you are.</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613308" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:28</guid>
				<title>Burning Down the House: AMQP revisited</title>
				<link>http://hintjens.com/blog:28</link>
				<description>

&lt;p&gt;When &lt;a href=&quot;http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol&quot;&gt;the Wikipedia page&lt;/a&gt; for a contentious topic shows no real argument, you know someone with time and money has something to hide. And AMQP is certainly contentious. In my experience, and because I&#039;m observant, rather than sensitive, the AMQP/1.0 authors are simple bullies who believe might makes right. But one learns to fight back against bullies, because, karma. I&#039;m going to coin a nickname for AMQP/1.0, which is the &amp;quot;&lt;strong&gt;Burning Down The House&lt;/strong&gt;&amp;quot; release.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613308&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 22 Oct 2012 11:25:55 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>When <a href="http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">the Wikipedia page</a> for a contentious topic shows no real argument, you know someone with time and money has something to hide. And AMQP is certainly contentious. In my experience, and because I'm observant, rather than sensitive, the AMQP/1.0 authors are simple bullies who believe might makes right. But one learns to fight back against bullies, because, karma. I'm going to coin a nickname for AMQP/1.0, which is the &quot;<strong>Burning Down The House</strong>&quot; release.</p> <p>Kelly, those screams you hear from current AMQP adopters aren't the screams of ignorance. Explaining nicely why AMQP/1.0 is so much better, <em>technically</em>, misses the point. Worse, it adds insult to injury. Oh poor AMQP/0.9.1 user, not only are you trapped in a burning house, but it's your fault, for being so bloody ignorant.</p> <p>The AMQP Working Group built a house, then invited people in for barbecue and free beer, and then deliberately burnt the house down, with the doors locked, because they weren't happy with it.</p> <p>Passing the buck to OASIS doesn't absolve the AMQP working group of a massive failure. Every single person associated with the AMQP/1.0 release should be, metaphorically, tarred and feathered and banned from ever again participating in a standards effort. Their names should be listed on that sanitized, purged Wikipedia page. AMQP/1.0 will go down in history as a prime <em>documented</em> example of how to fail a standardization effort and hurt a lot of people in the process.</p> <p>Easy prediction: the screams of anger and pain from the AMQP community are going to get louder as they realize just what's happened. In part this article is a careful, deliberate move because I don't want that anger bouncing back on me and my work. But also, it's an excuse to hit the bullies with a stick, because, karma.</p> <p>The calculation of the AMQP/1.0 authors, and those who support them, is that the pain inflicted on the AMQP community is worth the benefits. I've <a href="http://www.imatix.com/articles:whats-wrong-with-amqp">written before</a> that large rich firms <em>don't feel pain</em> like normal people. But they're also incredibly selfish and shortsighted.</p> <p><strong>AMQP/0.9.1 is legally and technically dead.</strong> The old spec is copyrighted by the AMQP Working Group and not remixable. There are no mechanisms for extensions, patches, fixes, anything.</p> <p><strong>AMQP/1.0 is touted as an upgrade for AMQP/0.9.1 when it's not.</strong> The two operate at different layers. One is a transport layer, one is a model layer. A healthy stack would swap transport layers over time and keep semantics compatible.</p> <p><strong>The pain that AMQP/1.0 will cause was entirely avoidable.</strong> It was plausible to replace the 0.9.1 transport layer but keep the exchange-binding-queue semantics. Even offer a gradual migration to other semantics. The 1.0 authors just couldn't be bothered. A matter of pride and greed. The house had to go.</p> <p><strong>95% of the AMQP community has invested in a dead standard.</strong> I count <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=amqp&amp;type=Everything&amp;repo=&amp;langOverride=&amp;start_value=1">4,528 repositories on GitHub that refer to AMQP</a>. There are <a href="https://github.com/search?q=amqp+1.0&amp;repo=&amp;langOverride=&amp;start_value=1&amp;type=Repositories&amp;language=">244 that refer to AMQP/1.0</a>. That makes 95% of the community wrong. This isn't marginal.</p> <p><strong>There is no documented cost/benefit argumentation.</strong> The costs of change cannot simply be ignored. There must be argumentation, explanation, justification for what is so wrong with AMQP/0.9.1 that it had to be destroyed.</p> <p><strong>AMQP/1.0 does not define semantic interoperability.</strong> The primary requirement for AMQP (to ensure interoperability between implementations) has been dropped. It's up to each vendor how they do messaging.</p> <p><strong>AMQP/1.0 is great for big vendors, tragic for users.</strong> The only value of a standard is to level the playing field so clients can choose vendors. AMQP/1.0 doesn't level the field, and is barely worth calling a 'standard'.</p> <p><strong>The whole point of the AMQP/1.0 change was to screw users.</strong> I can't believe a determined five-year effort to tilt the playing field against competition was just stupidity. The goal is control over the billion dollar messaging market.</p> <p>And finally, <strong>AMQP cannot survive this event.</strong> It's quite simple: AMQP attracted the pioneers, the leading edge. It's these people who invested most in that house that is now burning up.</p> <p>When we at iMatix quit the working group and shuttered years of work (and really, <a href="http://www.openamq.org">read the OpenAMQ docs</a> and realize this wasn't a toy project but a massive and sincere effort), it was because we saw the lunatics pouring gasoline, tried and failed to stop them. We described the problems in detail, and we built 0MQ as a safe refuge for anyone who would listen. But the barbecue and free beer continued, pulling in thousands of engineers, some of the best of a generation.</p> <p>So if you invested in AMQP, like we did, and find that you really don't have much say in the future, what can you do?</p> <p>Here's my answer: come to <a href="http://zero.mq">the 0MQ community</a>. We also have a <a href="http://rfc.zeromq.org/spec:15">peer-to-peer transport protocol</a> but it's kind of simple. We have independent implementations in several languages: C++, Java, Flash, Bash (yes), Node.js, even JavaScript in the browser. The main C++ stack has <a href="http://www.zeromq.org/bindings:_start">40+ language bindings</a>.</p> <p>You'll find a community that owns what it makes. A community that enjoys itself and rarely argues, because hey, send a patch. A <a href="http://rfc.zeromq.org/spec:22">contribution process</a> that is perfectly fair, open to all, and coherent. You'll find that whatever you were trying to do with AMQP you can do with 0MQ, with less stress and more fun. Of course the two technologies <a href="http://www.zeromq.org/docs:welcome-from-amqp">aren't the same</a>. One is dead, one is very much alive.</p> <p>We built 0MQ so that messaging would be fun again. We built 0MQ to kill AMQP/1.0 when it finally emerged, to keep messaging open and free to all, because we believe it's essential. We built 0MQ so that our messaging protocols would never be owned by greedy, selfish fools who treat quarterly profits as more valuable than community. Help us make that happen and teach the bullies a lesson. Because, karma.</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613308" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:12</guid>
				<title>NOM-1 grammar and notes</title>
				<link>http://hintjens.com/blog:12</link>
				<description>

&lt;p&gt;Time to get formal. Even the simplest contracts have to be robust against our charming but ineradicable &lt;a href=&quot;http://unprotocols.org/blog:8&quot;&gt;stupidity&lt;/a&gt;. Perhaps the simplest formal language for an unprotocol is &lt;a href=&quot;http://www.ietf.org/rfc/rfc2234.txt&quot;&gt;ABNF&lt;/a&gt;. So here is a first draft grammar for NOM-1, with notes. This page will morph into a real unprotocol draft spec.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613308&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Wed, 15 Jun 2011 13:57:45 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>Time to get formal. Even the simplest contracts have to be robust against our charming but ineradicable <a href="http://unprotocols.org/blog:8">stupidity</a>. Perhaps the simplest formal language for an unprotocol is <a href="http://www.ietf.org/rfc/rfc2234.txt">ABNF</a>. So here is a first draft grammar for NOM-1, with notes. This page will morph into a real unprotocol draft spec.</p> <p>First the whole thing:</p> <div class="code"> <pre> <code>NOM-1 = open-peering *use-peering open-peering = C:OHAI ( S:OHAI-OK / S:ROTFL ) use-peering = C:OHAI ( S:OHAI-OK / S:ROTFL ) / C:HUGZ S:HUGZ-OK / S:HUGZ C:HUGZ-OK / C:ICANHAZ ( S:ICANHAZ-OK / S:ROTFL ) / S:ICANHAZ ( C:ICANHAZ-OK / C:ROTFL ) / C:NOM / S:NOM ROTFL = version reserved %b0000 %b0000 reason-text version = %b0001 reserved = %b0000 reason-text = *VCHAR OHAI = version reserved %b0001 %b0000 address address = ( broadcast / hostname / hostnumber ) &quot;:&quot; port broadcast = &quot;*&quot; hostname = label *( &quot;.&quot; label ) label = 1*( %x61-7A / DIGIT / &quot;-&quot; ) hostnumber = 1*DIGIT &quot;.&quot; 1*DIGIT &quot;.&quot; 1*DIGIT &quot;.&quot; 1*DIGIT port = 1*DIGIT OHAI-OK = version reserved %b0010 %b0000 address HUGZ = version reserved %b0011 %b0000 HUGZ-OK = version reserved %b0100 %b0000 ICANHAZ = version reserved %b0101 sequence zmq-payload ICANHAZ-OK = version reserved %b0110 sequence zmq-payload sequence = 4BIT ; Incrementing for each ICANHAZ zmq-payload = 1*zmq-frame zmq-frame = frame-size frame-body frame-size = 2OCTET ; In network byte order frame-body = *OCTET ; frame-size octets NOM = version reserved %b0111 %b0000 zmq-payload</code> </pre></div> <p>and now the notes:</p> <ul> <li>A client opens a <em>peering</em> to a server. A server binds to and receives from some port. &quot;Client&quot; and &quot;server&quot; means exactly which node opens the peering, and which node accepts the peering. Nothing more. A peering has some state. We'll come to that.</li> </ul> <ul> <li>A client may start a peering-open dialog before the server is ready. In this case the client will send OHAIs repeatedly, at short intervals, until a server responds with OHAI-OK.</li> </ul> <ul> <li>The OHAI commands specifies an address, which the OHAI-OK command echoes. This lets a client broadcast OHAI to any listening server, and connect to the one that responds. We call this a <em>broadcast peering</em>.</li> </ul> <ul> <li>Once a peering is established, either peer can send unsolicited HUGZ, ICANHAZ, or NOM commands. A client can also send OHAI more than once to the same server, which may be needed since UDP can lose messages, e.g. the returning OHAI-OK.</li> </ul> <ul> <li>The ICANHAZ/ICANHAZ-OK commands are for the synchronous request-reply pattern (specifically for 0MQ REQ/REP sockets). NOM-1 does not use address envelopes, it is designed for single-hop request-reply.</li> </ul> <ul> <li>Since UDP will randomly drop messages, ICANHAZ implements a minimal resend capability. Each ICANHAZ command has an incrementing sequence number. The sender resends the ICANHAZ at short intervals at least as long as the peering is alive, until it receives a matching ICANHAZ-OK. The recipient will resend its last ICANHAZ-OK if it receives a duplicate request.</li> </ul> <ul> <li>Heartbeating consists of a ping-pong HUGZ/HUGZ-OK dialog. One peer sends HUGZ to the other, which replies with HUGZ-OK. Neither command has any payload. HUGZ and HUGZ-OK are not correlated. A peer should send HUGZ at regular intervals.</li> </ul> <ul> <li>Silence means a peer has died. A server should handle this by destroying all resources associated with that peering. A client should handle this by restarting the peering-open dialog.</li> </ul> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613308" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:11</guid>
				<title>First steps to NOM-1</title>
				<link>http://hintjens.com/blog:11</link>
				<description>

&lt;p&gt;NOM-1 is a lightweight messaging unprotocol for #zeromq over UDP. The name stands for &amp;quot;NOM-oriented messaging&amp;quot;. There&#039;s a good reason for the cuteness. If I gave it a confidence-inspiring name like &amp;quot;Message-oriented Datagram Protocol&amp;quot;, people might use it without further thought. The silly name will make life and public acceptance hard for NOM-1. So it&#039;s going to have work really hard to succeed.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613308&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Tue, 14 Jun 2011 12:35:33 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>NOM-1 is a lightweight messaging unprotocol for #zeromq over UDP. The name stands for &quot;NOM-oriented messaging&quot;. There's a good reason for the cuteness. If I gave it a confidence-inspiring name like &quot;Message-oriented Datagram Protocol&quot;, people might use it without further thought. The silly name will make life and public acceptance hard for NOM-1. So it's going to have work really hard to succeed.</p> <p>NOM-1 provides the basic support for 0MQ socket patterns, over UDP. It's the first in a series of unprotocols I want to build. They all have the same philosophy: to extend the 0MQ transport family with new, unusual, experimental, and hopefully useful protocols.</p> <p>If you've used UDP you'll know it's quite fun. No connections, you just send to a hostname:port, and if there's someone to catch the ball, a message arrives. If not, it gets dropped. And UDP will drop messages randomly anyhow. And it limits them to about 500 bytes. But it's fast, simple, doesn't do weird stuff behind the scenes.</p> <p>It turns out that 0MQ and UDP fit together neatly. Like UDP, 0MQ doesn't really have connections. They kind of come and go invisibly. It also drops messages when it gets bored. So, building some simple 0MQ-friendly semantics on top of UDP was fun.</p> <p>What you get is <em>not</em> like TCP at all. Here is what NOM-1 does already:</p> <ul> <li>It has a simple framing for commands and messages.</li> <li>It allows peers to establish 'peerings' (like connections but with fewer overloaded semantics and letters to type)</li> <li>It does heartbeating so that peers can destroy or disconnect peerings rapidly.</li> <li>It does broadcast peerings (this is fun, you connect to a host called '*' and the first that replies becomes the endpoint for the peering).</li> <li>It does asynchronous message transfer (single parts, no reliability)</li> <li>It does peering reconnection as peers go away and come back.</li> </ul> <p>All this is implemented in the <a href="https://github.com/imatix/vtx">VTX UDP driver</a>, which is the reference implementation for NOM-1. I'll probably make a stand-alone stack as a learning tool, because VTX is kind of abstract (thus complex) in itself.</p> <p>Next up will be basic request-reply retries, needed since UDP randomly drops packets and this'll kill any 0MQ REQ sockets waiting for an answer. It's <em>still</em> not TCP. For example, pub-sub or push-pull will work at full speed without any acknowledgements or retries. Unreliable pipelines? Why not.</p> <p>My test case is a simple client that does a broadcast connect, sends 'hello?' and waits for a response. The server does a bind, waits for a request, and replies with 'acknowledge'.</p> <p>Here's the client trace:</p> <div class="code"> <pre> <code>ph@ws200901:~/work/vtx/v3 :master$ vtx_testcli 11-06-14 14:11:33 I: create peering=0x25aee30 - 192.168.55.255:32000 11-06-14 14:11:33 C: hello? 11-06-14 14:11:34 I: send [OHAI] - 20 bytes to 192.168.55.255:32000 11-06-14 14:11:35 I: send [OHAI] - 20 bytes to 192.168.55.255:32000 11-06-14 14:11:36 I: send [OHAI] - 20 bytes to 192.168.55.255:32000 11-06-14 14:11:37 I: send [OHAI] - 20 bytes to 192.168.55.255:32000 11-06-14 14:11:38 C: hello? 11-06-14 14:11:38 I: send [OHAI] - 20 bytes to 192.168.55.255:32000 11-06-14 14:11:38 I: recv [OHAI-OK] - 22 bytes from 192.168.55.156:35860 11-06-14 14:11:38 I: rename peering from 192.168.55.255:32000 to 192.168... 11-06-14 14:11:38 I: bring up peering=0x25aee30 11-06-14 14:11:38 I: send [NOM] - 6 bytes to 192.168.55.156:35860 11-06-14 14:11:38 I: send [NOM] - 6 bytes to 192.168.55.156:35860 11-06-14 14:11:38 I: recv [NOM] - 13 bytes from 192.168.55.156:35860 11-06-14 14:11:38 I: recv [NOM] - 13 bytes from 192.168.55.156:35860 11-06-14 14:11:39 C: hello? 11-06-14 14:11:39 I: send [HUGZ] - 0 bytes to 192.168.55.156:35860 11-06-14 14:11:39 I: send [NOM] - 6 bytes to 192.168.55.156:35860 11-06-14 14:11:39 I: recv [HUGZ] - 2 bytes from 192.168.55.156:35860 11-06-14 14:11:39 I: send [HUGZ-OK] - 0 bytes to 192.168.55.156:35860 11-06-14 14:11:39 I: recv [HUGZ-OK] - 2 bytes from 192.168.55.156:35860 11-06-14 14:11:39 I: recv [NOM] - 13 bytes from 192.168.55.156:35860 11-06-14 14:11:40 C: hello? 11-06-14 14:11:40 I: send [NOM] - 6 bytes to 192.168.55.156:35860 11-06-14 14:11:40 I: recv [NOM] - 13 bytes from 192.168.55.156:35860 11-06-14 14:11:41 C: hello? 11-06-14 14:11:41 I: send [NOM] - 6 bytes to 192.168.55.156:35860 11-06-14 14:11:41 I: recv [NOM] - 13 bytes from 192.168.55.156:35860 11-06-14 14:11:42 C: hello? 11-06-14 14:11:42 I: send [NOM] - 6 bytes to 192.168.55.156:35860 ^C11-06-14 14:11:43 I: shutting down driver, 0 errors 11-06-14 14:11:43 I: delete peering=0x25aee30 - 192.168.55.156:35860</code> </pre></div> <p>And here's the server trace:</p> <div class="code"> <pre> <code>ph@ws200901:~/work/vtx/v3 :master$ vtx_testsrv 11-06-14 14:11:38 I: recv [OHAI] - 22 bytes from 192.168.55.156:48680 11-06-14 14:11:38 I: create peering=0xda7f00 - 192.168.55.156:48680 11-06-14 14:11:38 I: send [OHAI-OK] - 20 bytes to 192.168.55.156:48680 11-06-14 14:11:38 I: bring up peering=0xda7f00 11-06-14 14:11:38 I: recv [NOM] - 8 bytes from 192.168.55.156:48680 11-06-14 14:11:38 I: recv [NOM] - 8 bytes from 192.168.55.156:48680 11-06-14 14:11:38 S: acknowledge 11-06-14 14:11:38 I: send [NOM] - 11 bytes to 192.168.55.156:48680 11-06-14 14:11:38 S: acknowledge 11-06-14 14:11:38 I: send [NOM] - 11 bytes to 192.168.55.156:48680 11-06-14 14:11:39 I: send [HUGZ] - 0 bytes to 192.168.55.156:48680 11-06-14 14:11:39 I: recv [HUGZ] - 2 bytes from 192.168.55.156:48680 11-06-14 14:11:39 I: send [HUGZ-OK] - 0 bytes to 192.168.55.156:48680 11-06-14 14:11:39 I: recv [NOM] - 8 bytes from 192.168.55.156:48680 11-06-14 14:11:39 I: recv [HUGZ-OK] - 2 bytes from 192.168.55.156:48680 11-06-14 14:11:39 S: acknowledge 11-06-14 14:11:39 I: send [NOM] - 11 bytes to 192.168.55.156:48680 11-06-14 14:11:40 I: recv [NOM] - 8 bytes from 192.168.55.156:48680 11-06-14 14:11:40 S: acknowledge 11-06-14 14:11:40 I: send [NOM] - 11 bytes to 192.168.55.156:48680 11-06-14 14:11:41 I: recv [NOM] - 8 bytes from 192.168.55.156:48680 11-06-14 14:11:41 S: acknowledge 11-06-14 14:11:41 I: send [NOM] - 11 bytes to 192.168.55.156:48680 ^C11-06-14 14:11:42 I: shutting down driver, 0 errors 11-06-14 14:11:42 I: delete peering=0xda7f00 - 192.168.55.156:48680</code> </pre></div> <p>I'll have a draft spec up real soon now.</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613309" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:9</guid>
				<title>Cheap and Nasty, two essential patterns</title>
				<link>http://hintjens.com/blog:9</link>
				<description>

&lt;p&gt;Unprotocol enlightenment comes one step at a time. While it can be tempting to try to use generic solutions, it&#039;s often wiser to divide problems into classes, each with an optimal solution. Let&#039;s look at Cheap and Nasty, two essential patterns for unprotocol design.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613309&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 06 Jun 2011 19:14:54 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>Unprotocol enlightenment comes one step at a time. While it can be tempting to try to use generic solutions, it's often wiser to divide problems into classes, each with an optimal solution. Let's look at Cheap and Nasty, two essential patterns for unprotocol design.</p> <p><strong>Cheap</strong> is a pattern for low-volume chatty dialogs, and <strong>Nasty</strong> is a pattern for high-volume data flows. Realistic unprotocols often need to combine both chatty dialogs and high-volume data flows, and it's a common mistake &#8212; which I'm well aware of, having made it more than once &#8212; to try to use a single design to cover both these.</p> <p>Let's start with Cheap. Cheap is essentially synchronous, verbose, descriptive, and unstable. A Cheap message is full of rich information that changes practically for each application. Your goal as designer is to make this information easy to encode and to parse, trivial to extend for experimentation or growth, and highly robust against change both forwards and backwards. The ideal Cheap pattern looks like this:</p> <ul> <li>It uses a simple self-describing structured encoding for data, be it XML, JSON, tnetstrings, or some other. Any encoding is fine so long as there are standard simple parsers for it.</li> <li>It uses a straight request-reply model where each request has a success/failure reply. This makes it trivial to write correct clients and servers for a Cheap dialog.</li> <li>It doesn't try, even marginally, to be fast. Performance doesn't matter when you do something once a minute, or once a second.</li> </ul> <p>A good example of a Cheap protocol would be HTTP. But over ØMQ, you can create a Cheap protocol relatively trivially. A Cheap parser is something you take off the shelf, and throw data at. It shouldn't crash, shouldn't leak memory, should be highly tolerant, and should be relatively simple to work with. That's it.</p> <p>Now let's look at Nasty. Nasty is essentially asynchronous, terse, silent, and stable. A Nasty message carries minimal information that practically never changes. Your goal as designer is to make this information ultrafast to parse, and possibly even impossible to extend and experiment with. The ideal Nasty pattern looks like this:</p> <ul> <li>It uses a hand-optimized binary layout for data, where every bit is precisely crafted.</li> <li>It uses a pure asynchronous model where one or both peers send data without acknowledgments (or if they do, they use sneaky asynchronous techniques like credit-based flow control).</li> <li>It doesn't try, even marginally, to be friendly. Performance is all that matters when you are doing something several million times per second.</li> </ul> <p>A good example of a Nasty protocol would be ØMQ's publish-subscribe protocol, which is so brutally terse that it feels more like a weapon invented by Iain M. Banks than a network protocol. A Nasty parser is something you write by hand, which writes or reads bits, bytes, words, and integers individually and precisely. It rejects anything it doesn't like, does no memory allocations at all, and never crashes.</p> <p>You'll see people trying to use Cheap everywhere (&quot;everything is an XML message!&quot;), or Nasty for everything (&quot;Our wire level protocol is 100% binary!&quot;). Or, some intermediate solution that is neither Cheap, nor Nasty (&quot;we use protobufs for everything!&quot;). The results will be mediocre. Don't be afraid of going to extremes, when you're writing software that has to be extremely good.</p> <p>Remember: Cheap for the chatty stuff, Nasty for the real work. Enjoy!</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613309" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:5</guid>
				<title>Majordomo and Titanic in PHP</title>
				<link>http://hintjens.com/blog:5</link>
				<description>

&lt;p&gt;The &lt;a href=&quot;http://rfc.zeromq.org/spec:7&quot;&gt;Majordomo Protocol&lt;/a&gt; and &lt;a href=&quot;http://rfc.zeromq.org/spec:9&quot;&gt;Titanic Service Procotol&lt;/a&gt; are two neat little unprotocols built on top of ØMQ. Ian Barber (@ianbarber) has just made PHP implementations of these.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613309&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Thu, 05 May 2011 15:26:20 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>The <a href="http://rfc.zeromq.org/spec:7">Majordomo Protocol</a> and <a href="http://rfc.zeromq.org/spec:9">Titanic Service Procotol</a> are two neat little unprotocols built on top of ØMQ. Ian Barber (@ianbarber) has just made PHP implementations of these.</p> <p>Like good little unprotocols, MDP and TSP are easy to implement. The <a href="http://zguide.zeromq.org/php:mdbroker">Majordomo broker in PHP</a> is about 300 lines of code, and the <a href="http://zguide.zeromq.org/php:mdcliapi">client stack</a> is 150 lines of code.</p> <p>Majordomo, in case you're using or interested in ØMQ, is a service-oriented protocol that connects a set of clients to a set of service workers. It's basically a shared queue model. Titanic turns Majordomo into a fully async persistent service model. If you think it's hard to do persistent messaging across ØMQ, look at Titanic. It isn't fast (one message per disk file is the KISS implementation) but obviously could be made much faster, using the same protocol and stacks.</p> <p>Majordomo and Titanic already work in C, and Lua.</p> <p><em>Edit: and also here's an independent implementation of Majordomo <a href="https://github.com/guidog/pyzmq-mdp">in Python</a>.</em></p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613309" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:4</guid>
				<title>Using a RESTful Transport Layer</title>
				<link>http://hintjens.com/blog:4</link>
				<description>

&lt;p&gt;Couple of us are developing a new mobile concept, which I&#039;ll write about later somewhere else. The little thing talks to a web service, and for this we&#039;re using RestTL, an unprotocol that &amp;quot;&lt;em&gt;specifies standard rules for representing resources, and standard mechanisms for working with them in a RESTful fashion over a plain HTTP client-server network.&lt;/em&gt;&amp;quot;&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613309&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 02 May 2011 10:13:32 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>Couple of us are developing a new mobile concept, which I'll write about later somewhere else. The little thing talks to a web service, and for this we're using RestTL, an unprotocol that &quot;<em>specifies standard rules for representing resources, and standard mechanisms for working with them in a RESTful fashion over a plain HTTP client-server network.</em>&quot;</p> <p>RestTL emerged about two years ago as the lowest layer of a RESTful stack called <a href="http://www.restms.org">RestMS</a>. It's a lovely little transport layer, abstract and extensible. We made it (Steve Vinoski, Brad Clements, and myself) after refactoring the earlier RestMS draft into three layers. Here's a common pattern for unprotocols: start quickly, make it work, then refactor into neater and more abstract layers.</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613309" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:3</guid>
				<title>Finally, the ØMQ wire level protocol!</title>
				<link>http://hintjens.com/blog:3</link>
				<description>

&lt;p&gt;ZMTP/1.0 defines the wire level protocol used by ØMQ (versions 2.x) over TCP. It has a &lt;em&gt;framing layer&lt;/em&gt;, a &lt;em&gt;connection layer&lt;/em&gt;, and a &lt;em&gt;content layer&lt;/em&gt;. It&#039;s a neat little unprotocol that is free to remix, lightweight, and easy to understand.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613309&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 30 Apr 2011 15:59:02 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>ZMTP/1.0 defines the wire level protocol used by ØMQ (versions 2.x) over TCP. It has a <em>framing layer</em>, a <em>connection layer</em>, and a <em>content layer</em>. It's a neat little unprotocol that is free to remix, lightweight, and easy to understand.</p> <p>On the #zeromq IRC channel, on Saturday 30th April 2011:</p> <div class="code"> <p>(11:46:23 AM) rgl: can you point me to the document that describes the wire format of the several socket types?<br /> (11:46:46 AM) pieterh: rgl: unfortunately, there's no single document<br /> (11:47:00 AM) pieterh: there is some information in the zmq_tcp man page<br /> (11:48:39 AM) pieterh: we really do need to make a proper documentation of the wire format, no real excuses<br /> &#8230;<br /> (12:10:21 PM) pieterh: I'm going to start on a new RFC, this annoys the heck out of me<br /> &#8230;<br /> (02:17:48 PM) pieterh: ok, finished draft of full wire level protocol<br /> (02:18:00 PM) pieterh: rgl: if you're still around: <a href="http://rfc.zeromq.org/spec:13">http://rfc.zeromq.org/spec:13</a></p> </div> <p>Yeah, it actually took <em>two whole hours</em> to scrape this little unprotocol together from a bunch of leftover potato peelings, ØMQ man pages, and my warped imagination.</p> <p>Presumably it's full of errors, but as the great Digistan says, &quot;<em>specifications should take minutes to explain, hours to design, days to write, weeks to prove, months to become mature, and years to replace.</em>&quot;</p> <p>First person to implement ZMTP in JavaScript wins 1,000 internets. YARLY.</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613309" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:2</guid>
				<title>Keywords for Unprotocols</title>
				<link>http://hintjens.com/blog:2</link>
				<description>

&lt;p&gt;Up to now, software protocols have been designed with levels of formality that tend to exclude facile participation from the fat belly of developers. tl;dr: protocols in suits bore the pants off most of us. We propose the concept of the &amp;quot;unprotocol&amp;quot;, which is a lightweight spec that&#039;s easy to read, fast to implement, and obvious to get right.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613309&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 30 Apr 2011 15:50:55 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>Up to now, software protocols have been designed with levels of formality that tend to exclude facile participation from the fat belly of developers. tl;dr: protocols in suits bore the pants off most of us. We propose the concept of the &quot;unprotocol&quot;, which is a lightweight spec that's easy to read, fast to implement, and obvious to get right.</p> <p>Inspired by and blatantly ripped-off from @monadic / Alexis Richardson's LOLMQ.</p> <h2><span>Keyword List</span></h2> <p>The core philosophy of unprotocols is that they should speak the same language as the people who use them. So:</p> <ul> <li><strong>OHAI</strong> - sent by a client to a server when it wants to initiate a dialog.</li> </ul> <ul> <li><strong>ORYL?</strong> - sent by a server to a client when it wants to get authentication information such as a password hash.</li> </ul> <ul> <li><strong>YARLY</strong> - sent by a client to a server when it wants to authenticate with some information.</li> </ul> <ul> <li><strong>ICANHAZ?</strong> - sent by a client to a server, along with some arguments, to request some resource from the server.</li> </ul> <ul> <li><strong>CHEEZBURGER</strong> - sent by a server to a client, along with some properties, to indicate a resource delivered from server to client.</li> </ul> <ul> <li><strong>NOM</strong> - sent by a client to a server to acknowledge that it's happily received some resource.</li> </ul> <ul> <li><strong>LOL</strong> - sent by a client to a server to reject a resource as inedible.</li> </ul> <ul> <li><strong>KITTEH</strong> - used in general to indicate a client or server peer. Note: considered rather too cute for srs unprotocols.</li> </ul> <ul> <li><strong>KTHXBAI</strong> - sent by a server to a client, or a client to a server, when it finishes some dialog.</li> </ul> <ul> <li><strong>HUGZ</strong> - sent by a server to a client, or a client to a server, to indicate that it's still around and not going anywhere just now. Kind of like a keep-alive heartbeat.</li> </ul> <ul> <li><strong>SRSLY?</strong> - sent by a server to a client when it refuses some operation due to access rights.</li> </ul> <ul> <li><strong>RTFM</strong> - sent by a server to a client that uses an invalid value or argument.</li> </ul> <ul> <li><strong>WTF?</strong> - sent by a server to a client when it refuses some operation because it's not meaningful. After a WTF? the client may retry.</li> </ul> <ul> <li><strong>ROTFL</strong> - sent by a server to a client when it refuses some operation and disconnects the client for being silly.</li> </ul> <ul> <li><strong>PWNED</strong> - sent by a server to a client when it cannot perform some operation due to being pretty much exhausted.</li> </ul> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613309" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:1</guid>
				<title>Elegant Little Pieces</title>
				<link>http://hintjens.com/blog:1</link>
				<description>

&lt;p&gt;Unprotocols are elegant little pieces that we remix to create order and sanity in the swirling chaos that is the software industry. There are, IMO, three essential properties of an unprotocol. One, it&#039;s immune from capture. Two, it&#039;s lightweight. Three, it uses natural semantics. Said @leastfixedpoint: &lt;span style=&quot;font-style:italic&quot;&gt;It&#039;s a mystery to me why AMQP isn&#039;t yet specified in little elegant pieces like this: &lt;a href=&quot;http://rfc.zeromq.org/spec:13&quot;&gt;http://rfc.zeromq.org/spec:13&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613309&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 30 Apr 2011 15:30:21 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>Unprotocols are elegant little pieces that we remix to create order and sanity in the swirling chaos that is the software industry. There are, IMO, three essential properties of an unprotocol. One, it's immune from capture. Two, it's lightweight. Three, it uses natural semantics. Said @leastfixedpoint: <span style="font-style:italic">It's a mystery to me why AMQP isn't yet specified in little elegant pieces like this: <a href="http://rfc.zeromq.org/spec:13">http://rfc.zeromq.org/spec:13</a>.</span></p> <p>Welcome to unprotocols.org.</p> <p>Let's take these three essential properties one by one. In 2008 I wrote <a href="http://www.digistan.org/text:rationale">an analysis</a> for the <a href="http://www.digistan.org">Digital Standards Organization</a> on the different ways of capturing a standard. It's an amusing way to look at open standards. Instead of listing properties like &quot;Freely available text&quot; and &quot;Patents licensed under reasonable and non-discriminatory terms&quot;, the &quot;freedom from capture&quot; approach lets us say that &quot;<em>A standard is a published specification. It is a free and open standard if it is immune to vendor capture at all stages in its life-cycle.</em>&quot;</p> <p>And in real life, standards do get captured, even with the best intentions. The most common is simple copyright. Yes, you can implement this spec. No, you may not mix it into new shapes and forms. For me, a work that can't be remixed isn't culture. At best it's a snapshot of culture. And the best contract for remixing software is the GPL, because it (a) forces anyone who mixes someone's work to reciprocate and allow mixing of their work, and (b) it has clauses to prevent patent hijacks.</p> <p>So, unprotocols are GPL licensed. Freaky, huh? Yet it works really nicely. Take any of the specs at <a href="http://rfc.zeromq.org">http://rfc.zeromq.org</a>, and feel free to remix. This is literally how the process works.</p> <p>OK, part two: lightweight. Again, to quote <a href="http://www.digistan.org/spec:1">Digistan.org</a> (I love that website), <em>&quot;Specifications should take minutes to explain, hours to design, days to write, weeks to prove, months to become mature, and years to replace.&quot;</em></p> <p>If it takes more than a few pages to define a contract, then there's something wrong. Long, complex, tedious contracts usually mean one party is cheating the other. Whereas a conventional protocol spec might be several hundred pages long, the unprotocol equivalent would be a stack of three or four 5-page specs.</p> <p>Finally, &quot;natural semantics&quot;. By this, I mean that an unprotocol should read naturally, use words that are familiar, and be obvious. If it's too complex, it's wrong. In my next posting I'll propose a set of Keywords for Unprotocols that show what I mean.</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613309" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
				</channel>
</rss>