<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wikidot="http://www.wikidot.com/rss-namespace">

	<channel>
		<title>Hintjens</title>
		<link>http://hintjens.com</link>
		<description></description>
				<copyright></copyright>
		<lastBuildDate>Wed, 09 Oct 2019 09:32:48 +0000</lastBuildDate>
		
					<item>
				<guid>http://hintjens.com/blog:27</guid>
				<title>How to Make Money from Open Source</title>
				<link>http://hintjens.com/blog:27</link>
				<description>

&lt;p&gt;There are, it has been said, two ways to make really large-scale software. Option One is to throw massive amounts of money and problems at empires of smart people, and hope that what emerges is not yet another career killer. If you&#039;re very lucky, and are building on lots of experience, and have kept your teams solid, and are not aiming for technical brilliance, and are furthermore incredibly lucky, it works.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613568&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Tue, 18 Sep 2012 11:02:57 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>There are, it has been said, two ways to make really large-scale software. Option One is to throw massive amounts of money and problems at empires of smart people, and hope that what emerges is not yet another career killer. If you're very lucky, and are building on lots of experience, and have kept your teams solid, and are not aiming for technical brilliance, and are furthermore incredibly lucky, it works.</p> <p>But gambling with hundreds of millions of others' money isn't for everyone. For the rest of us who want to build large-scale software, there's Option Two, which is open source, and more specifically, <em>free software</em>. You may be asking how the choice of software license is relevant to the scale of the software you build. It's the right question.</p> <p>The brilliant and visionary Eben Moglen once said, roughly, that a free software license is the contract on which a community builds. When I heard this, about ten years ago, the idea came to me, <em>can we deliberately grow free software communities</em>?</p> <p>Ten years later, the answer is &quot;yes&quot;, and there is almost a science to it. I say &quot;almost&quot; because we don't have much evidence of people doing this deliberately with a documented, reproducible process. It is what I'm trying to do with <a href="http://softwareandsilicon.com/chapter:2#toc5">Social Architecture</a>. My pilot experiment was ZeroMQ, after Wikidot, after Digistan and the FFII. There were&#8230; a lot of pilot projects. Anyhow, it seems clear that any explanation of how to build software at scale (which, experience tells us, is where the Money (with a capital M) is) must discuss how to build free software communities.</p> <h2><span>The Game</span></h2> <p>Software is my business: I code to eat, and to feed my kids and to make sure my wife doesn't leave me for someone nicer and better looking. Of course I <em>love</em> coding and that sensation of sculpting perfect functionality out of the raw mass of possibility. But the world doesn't care how passionately we feel. We wrest our living from a market that is largely uninterested, and often hostile when it does notice. This is the Game, and the full strategy of how to win it is for a full book.</p> <p>What I will say here is that you have to identify and destroy your competitors, that you have to develop active strategies, learn rapidly, move quickly, and in general appreciate the Game as a constant competition in which every participant is an ally, an enemy, or the ground over which you are fighting.</p> <p>How seriously you take the Game is up to you, but keep in mind that my advice for the rest of this article is aimed at helping you win, if and when you play it.</p> <h2><span>The Contract</span></h2> <p>When I write my best-selling book, &quot;How to Make Big $$$ From Open Source&quot;, the first sentence will be &quot;Use the GPL.&quot;</p> <p>Here is a true story, it happened to the eldest brother-in-law of the cousin of a friend of mine's colleague at work. His name was, and still is, Patrick.</p> <p>Patrick was a computer scientist, with a PhD in advanced network topologies. He spent two years and his savings building a new product, and choose the BSD license because he believed that would get him more adoption. He worked in his attic, at great personal cost, and proudly published his work. People applauded, for it was truly fantastic, and his mailing lists were soon abuzz with activity and patches and happy chatter. Many companies told him how they were saving millions using his work. Some of them even paid him for consultancy and training. He got invited to speak at conferences. He started a small business, hired a friend to work with him, and dreamed of making it big.</p> <p>Then one day, someone pointed him to a new project, GPL licensed, which had forked his work and was improving on it. He was irritated and upset, and asked how people &#8212; fellow open sourcers, no less! &#8212; would so shamelessly steal his code. There were long arguments on the list about whether it was even legal to relicense their BSD code as GPL code. Turned out, it was. He tried to ignore the new project but then he soon realized that new patches coming from that project <em>couldn't even be merged back</em> into his work!</p> <p>Worse, the GPL project got popular and some of his core contributors made first small, and then larger patches to it. Again, he couldn't use those changes, and he felt abandoned. Patrick went into a depression, his girlfriend left him for an international currency dealer called, weirdly, Patrice, and he stopped all work on the project. He felt betrayed, and utterly miserable. Finally he took a job as an architect for a cloud company, and by the age of forty, he had stopped programming even for fun.</p> <p>Poor Patrick, I almost felt sorry for him. Then I asked him, &quot;why didn't you choose the GPL?&quot; &quot;Because it's a restrictive viral license&quot;, he replied. I told him, you may have a PhD, and you may be the eldest brother-in-law of the cousin of a friend of my colleague, but you are an idiot and Monique was smart to leave you. You published your work saying, &quot;please steal my code as long as you keep this 'please steal my code' statement in the resulting work&quot;, and when people did exactly that, you got upset. Worse, you were a hypocrite because when they did it in secret, you were happy, but when they did it openly, you got upset.</p> <p>Seeing your hard work captured by a smarter team and then used against you is enormously painful, so why even make that possible? Every proprietary project that uses BSD code is capturing it. A public GPL fork is perhaps more humiliating, but it's totally, utterly self-inflicted.</p> <p>BSD says &quot;eat me&quot;. It was designed specifically by a university (Berkeley) with no profit motive, to leak work and effort. It is a way to push subsidized technology at below its cost price, a dumping of under-priced code in the hope that it will break the market for others. BSD is an <em>excellent</em> tool in the Game, but only if you're a large well-funded institution that can afford to use Option One.</p> <p>For the rest of us, small businesses who aim our investments like precious bullets, leaking work and effort is unacceptable. We cannot afford to subsidize our market. We cannot afford battles with those we should naturally be allies with. We cannot afford to make fundamental business errors because in the end, that means we have to fire people.</p> <p>It comes down to behavioral economics and game theory. <em>The license we choose modifies the economics of those who use our work</em>. In the Game there are allies, enemies, and lunch. BSD makes most people see us as lunch. Closed source makes most people see us as enemies (do you <em>like</em> paying people for software?) GPL, however, makes most people, with the exception of the Patricks of the world, our allies. Any fork of 0MQ is license compatible with 0MQ, to the point where we <em>encourage</em> forks as a valuable tool for experimentation.</p> <h2><span>The Process</span></h2> <p>If you've accepted my thesis up to now, great! You may actually get rich from your free software products. Now, I'll explain the rough process by which we actually build an open source community.</p> <p>You recall the <a href="http://unprotocols.org/blog:19">simplicity-oriented design process</a>, where I claimed that we build successfully accurate software by successfully exploring the problem landscape, rather than by sheer intellectual effort. Keep this in mind. Now, see your community as a group exploring that landscape and sharing the results of their work.</p> <p>Your goal as leader of a community is to motivate people to get out there and explore; to ensure they can do so safely and without disturbing others; to reward them when they make successful discoveries; and to ensure they share their knowledge with everyone else.</p> <p>It is an iterative process. You make a small product, at your own cost, but in public view. You then build a small community around that product. If you have a small but real hit, the community then helps design and build the next version, and grows larger. And then that community builds the next version, and so on. It's evident that the more control you try to assert over the material results, the less people will want to participate.</p> <h2><span>Crazy, Beautiful, and Easy</span></h2> <p>You need a goal that's crazy and simple enough to get people out of bed in the morning. Your community has to attract the very best people and that demands something special. With 0MQ, we said we were going to make &quot;the Fastest. Messaging. Ever.&quot;, which qualifies as a good motivator. If we'd said, we're going to make &quot;a smart transport layer that'll connect your moving pieces cheaply and flexibly across your enterprise&quot;, we'd have failed.</p> <p>Then your work must be beautiful, immediately useful and attractive. Your contributors are users who want to explore just a little beyond where they are now. Make it simple, elegant, brutally clean. <a href="http://unprotocols.org/blog:19">SOD it</a>, and I mean that. The experience when people run or use your work should be an emotional one. They should <em>feel</em> something, and if you accurately solved even just one big problem that until then they didn't quite realize they faced, you'll have a small part of their soul.</p> <p>And then, easy to understand, use, and join. Too many projects have barriers to access: put yourself in the other person's mind and see all the reasons they come to your site, thinking &quot;Uhm, interesting project, but&#8230;&quot; and then leave. You want them to stay, try it, just once. Use github and put the issue tracker right there.</p> <p>If you do these things well, your community will be smart but more importantly, will be intellectually and geographically diverse. This is really important. A group of like-minded experts cannot explore the problem landscape well. They tend to make big mistakes. Diversity beats education any time.</p> <h2><span>Stranger, meet Stranger</span></h2> <p>How much up-front agreement do two people need to work together on something? In most organizations, a lot. But you can bring this cost down to zero, and then people can collaborate without having ever met, done a phone conference, meeting, or business trip to discuss Roles and Responsibilities.</p> <p>You need well-written rules that are designed by cynical people like me to force strangers into mutually beneficial collaboration instead of conflict. The GPL is a good start. Github and its fork/merge strategy is a good follow-up. And then you want something like our <a href="http://rfc.zeromq.org/spec:16">C4 rulebook</a> to control how work actually happens.</p> <p>C4 (which I now use for every new open source project) has detailed (and tested) answers to a lot of common mistakes people make. For example, the sin of working off-line in a corner with others &quot;because it's faster&quot;. Transparency is essential to get trust, which is essential to get scale. By forcing every single change through a single transparent process, you build real trust in the results.</p> <p>Another cardinal sin that many open source developers make is to place themselves above others. &quot;I founded this project thus my intellect is superior to that of others&quot;. It's not just immodest and rude, and usually inaccurate, it's also poor business. The rules must apply equally to everyone, without distinction. You are part of the community. Your job, as founder of a project, is not to impose your vision of the product over others, but to make sure the rules are good, honest, and <em>enforced</em>.</p> <h2><span>Infinite Property</span></h2> <p>One of the saddest myths of the knowledge business is that ideas are a sensible form of property. It's medieval nonsense that should have been junked along with slavery, but sadly it's still making too many powerful people too much money.</p> <p>Ideas are cheap. What does work sensibly as property is the hard work we do in building a market. &quot;You eat what you kill&quot; is the right model for encouraging people to work hard. Whether it's moral authority over a project, money from consulting, or the sale of a trademark to some large, rich firm: if you make it, you own it. But what you really own is &quot;footfall&quot;, participants in your project, which ultimately defines your power in the Game.</p> <p>To do this requires infinite free space. Thankfully, github solved this problem for us, for which I will die a grateful person (there are many reasons to be grateful in life, but this is one of them).</p> <p>You cannot scale a single project with many owners like you can scale a collection of many small projects, each with fewer owners. When we embrace forks, a person can become an &quot;owner&quot; with a single click. Now they just have to convince others to join, by demonstrating their unique value.</p> <p>So in 0MQ we aimed to make it easy to write bindings on top of the core library, and we stopped trying to make those bindings ourselves. This created space for others to make those, become their owners, get that credit.</p> <h2><span>Making Money from Open Source</span></h2> <p>Now, finally, how to make money from your successful open source project. Start by realizing that it will take years to get to the point where you can make real money. Patience, an economical lifestyle, and no debts are as important as anything else.</p> <p>To make money from your open source, you must ensure your competitors stay or become marginal. That is fairly straight-forward: find their weaknesses, attack those, protect or hide your own weaknesses, repeat until it's over. If you don't think this is an ethical way to do business, just wait a few years. You will either learn, or become an employee . By using the GPL we should already have converted most compatible projects into allies, so it's fair to say the GPL is pacifist as well as ultra-capitalist.</p> <p>Then, you must brand your product. The branding is key to explaining to people why they will send you real money (instead of emails asking you to do their homework). Choose a bold, confident logo and name, and website, and focus your brand on your core values, which are &quot;crazy, beautiful, easy&quot;.</p> <p>Now, what can you sell? Forget about &quot;commercial licenses&quot;. Part of your deal with your growing community of contributors was that you would never fork their work to compete against them. This means no copyright assignments, and every patch owned by its author.</p> <p>How about commercial add-ons? Perhaps, but in my experience you will always benefit more from building more open source.</p> <p>So, this leaves two or three options. One is to sell your services helping others use the technology. The nice thing is you can scale this rapidly. After all, you have a community of ready-trained experts to call on, right? Who better to hire than the guy who just spent a month learning the source code.</p> <p>The second option is to sell your business, for which you have to plan well in advance. What you in fact sell then isn't the copyrights, since you don't own these fully (or even in majority). It's the trademark, reputation, and the goodwill of the community. The new owner may make a mess of things. In that case you, or anyone else, can fork the whole thing right back to where it was.</p> <p>Depending on the type of product you're making, there will be other services to sell. Support agreements (&quot;pay us X per year and we'll fix any issues you hit within X hours or days&quot;) are an easy sell to larger customers. Advertisements can be profitable if you run very large websites. You may find lecture tours and workshops good income.</p> <p>Finally, and here's the real money maker: t-shirts with pictures of cats saying funny things about your software. &quot;I UZES 0MQ TO GETS MAI CHEEZEBURGERS&quot; is our most popular one these days.</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613568" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:26</guid>
				<title>The End of Stable Releases?</title>
				<link>http://hintjens.com/blog:26</link>
				<description>

&lt;p&gt;The C4 process we adopted some time back for ZeroMQ (except our dependency on Jira), CZMQ, and some other projects, looks like it&#039;s working as planned. But the drama of science lies in the extremes. If we really can reduce change latency to almost zero using C4, how does this affect how we deliver stable releases?&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613568&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Fri, 25 May 2012 17:01:17 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>The C4 process we adopted some time back for ZeroMQ (except our dependency on Jira), CZMQ, and some other projects, looks like it's working as planned. But the drama of science lies in the extremes. If we really can reduce change latency to almost zero using C4, how does this affect how we deliver stable releases?</p> <p>First, what do I mean by &quot;change latency&quot; and why is this important? Without diving too deep into the theories of collective intelligence and problem solving, C4 asserts that the optimal design for a software development team is two halves, one that sets challenges, and one that solves them. While pair programming puts two drivers behind the wheel, it gives no guarantee that they drive in the right direction. The challenge/solution pairing gives one person, or group, the task of defining the right directions, and another the task of driving as fast as possible in that direction.</p> <p>C4 drives a constant stream of such challenges, written as issues that capture problems. As long as the people writing the issues have some empathy with real users, or are real users, the product moves accurately in the right direction.</p> <p>So each answer to a well-expressed problem comes in as a change to the software product. About 10-20% of these changes will be wrong, badly done, or solving problems that are themselves &quot;wrong&quot;. The usual approach with software development is to accumulate a large number of changes, and then weed out the errors one by one, until the code is stable enough for production use.</p> <p>Even the very best programmers will make significant numbers of mistakes. They don't always appear as bugs; they can be too-complex designs, solutions to problems no-one cares about, features that don't work as expected, functionality that people want which is &quot;impossible&quot; due to other design decisions, and so on. Even a really excellent library like ZeroMQ has had many of these mistakes in it. Often we end up choosing a piece of software just because the good outweighs the bad. None, it seems, can be perfect.</p> <p>However, with C4 we apply changes directly to the master version and we look for a fast yes/no answer to the question, &quot;was that a good change?&quot; We don't use branches because they slow down the time it takes to get this answer. We don't over-discuss pull requests for the same reason. In fact we're doing whatever it takes to reduce the round-trip time from &quot;I have identified a problem and propose solution X&quot; to &quot;Yes, solution X makes sense and it seems to work fine&quot; or &quot;solution X is insane and I've make a patch that reverts it&quot;.</p> <p>With ZeroMQ we're now getting change latencies of a few hours.</p> <p>What does this mean for stable releases? I'm not yet certain but what seems to be emerging is that the git master is perfect 80-90% of the time, and one patch away from perfection the remaining 10-20% of the time. The remaining issues in ZeroMQ are all in old code, none in new code. This is highly significant.</p> <p>Let's think this through again. Historically, the only reason for making stable releases was that we had lots of change that took months or years to fully validate. I'm fully sure now, with evidence, that making large changes is both unnecessary, and sub-optimal. Instead, with C4 we aim for a steady stream of small iterative changes, where each can be validated or rejected very rapidly. Thus, we have removed the need for stabilization.</p> <p>C4 is also a formal contract for ongoing interoperability. That is, we <em>do not</em> break old APIs or protocols. In the old days we happily broke these, and bumped the version number. That didn't help anyone, in fact. People stayed away from ZeroMQ/3.0 and ZeroMQ/4.0 because interoperability is more important than new features.</p> <p>We will make a stable release candidate of ZeroMQ/3.1 soon. But I'm curious to see how far that stable candidate diverges from master. We'll continue to make formal releases for obvious reasons: people expect this, they do not trust github masters, they need well-labeled packages for internal deployment. But really, over time, I think the whole concept of &quot;stable releases&quot; will disappear, and be replaced by &quot;latest master that passed all tests&quot;.</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613568" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:25</guid>
				<title>The Myth of Intelligent Design</title>
				<link>http://hintjens.com/blog:25</link>
				<description>

&lt;p&gt;The dominant theory of design is that you take smart, creative people and money, and produce amazing products. The smarter the people, the better the results. I&#039;m going to claim that theory is bogus and based on a quasi-religious model of the &amp;quot;inventor&amp;quot; and &amp;quot;invention&amp;quot; as a function of individual minds. As an alternative I&#039;ll present the Theory of Heuristic Innovation, which states roughly that we do not invent solutions, we discover them, and that discovery process can be highly automated.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613568&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Thu, 10 May 2012 21:10:04 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>The dominant theory of design is that you take smart, creative people and money, and produce amazing products. The smarter the people, the better the results. I'm going to claim that theory is bogus and based on a quasi-religious model of the &quot;inventor&quot; and &quot;invention&quot; as a function of individual minds. As an alternative I'll present the Theory of Heuristic Innovation, which states roughly that we do not invent solutions, we discover them, and that discovery process can be highly automated.</p> <h2><span>Why Discuss This?</span></h2> <p>Presenting ZeroMQ at Mix-IT in Lyon a couple of weeks ago, I was asked several times for the &quot;roadmap&quot;. My answer was, roadmaps are bad for several reasons. First, they make promises we can rarely keep, which causes problems for our users. Second, they claim territory and make it harder for others to participate. Lastly, they preempt the thinking process of the community. The audience didn't really like my answer. So un-French. Software engineers don't like the notion that powerful, effective solutions can come into existence without an intelligent designer actively thinking things through. And yet no-one in that room would question evolution. A strange irony, and one I want to explore further.</p> <h2><span>The Theory of Individual Creativity</span></h2> <p>In the dominant theory, brilliant individuals reflect on large problem sets and then carefully and precisely create a solution. Sometimes they will have &quot;eureka&quot; moments where they &quot;get&quot; brilliantly simple answers to whole large problem sets. The inventor, and the process of invention are rare, precious, and can command a monopoly. History is full of such individuals.</p> <p>Looking closer, however, the facts don't match. History doesn't show lone inventors. It shows lucky people who steal or claim ownership of ideas that are being worked on by many. It shows brilliant people striking lucky once, and then spending decades on fruitless and pointless quests. The best known large-scale inventors like Thomas Edison were in fact just very good at systematic broad research done by large teams. It's like claiming that Steve Jobs invented every device made by Apple. It is a nice myth, good for marketing, but utterly incorrect.</p> <p>Recent document history shows this very well. The Internet is surely one of the most innovative and fast-moving areas of technology. It has no inventor. Instead it has a large economy of people who have carefully and progressively solved a long series of immediate problems, documented their answers, and made those available to all. The innovative nature of the Internet comes not from a collection of Einsteins. It comes from RFCs anyone can use and improve. It comes from open source software anyone can use and improve. It comes from sharing, scale of community, and the continuous accretion of good solutions and disposal of bad ones.</p> <h2><span>The Theory of Heuristic Innovation</span></h2> <p>Here is the Theory of Heuristic Innovation (v0.2):</p> <ol> <li>There is an infinite problem/solution terrain.</li> <li>This terrain changes over time according to external conditions.</li> <li>We can only accurately perceive problems we are close to.</li> <li>We can rank the cost/benefit economics of problems using a market for solutions.</li> <li>There is one temporarily optimal solution to any solvable problem.</li> <li>We can approach this optimal solution heuristically, and mechanically.</li> <li>Our intelligence can make this process faster and more accurate but does not replace it.</li> </ol> <p>It's an approximation. Feel free to send me patches.</p> <h2><span>What does This Mean?</span></h2> <p>First, and most broadly, it means that we do not invent solutions, but we discover them. Given a well-defined problem, there is exactly one optimal solution, and our work as software engineers is to climb the solution terrain until we find it. There may be local peaks. We may have to back-track. We make mistakes. But if we have a good process for climbing that terrain and we apply that process mechanically, we will eventually find the optimum.</p> <p>Second, this means that individual talent is helpful only in the speed with which we move. Intelligence moves us faster but does not make any fundamental difference in the outcome. The process is much more significant than talent. Which is why so many talented engineers produce trashware, and why teams working in the same space systematically seem to discover the same solutions.</p> <p>Thirdly, it means that old solutions to old problems can become obsolete as the terrain shifts. Technological and environmental changes are the main factors here.</p> <p>Finally, it means that our primary goal in producing software should be to define the best possible process, and then learn to apply it mechanically and systematically.</p> <p>As a correlation, we can bootstrap this by applying any given process to the process itself.</p> <h2><span>Elements of a Mechanical Process</span></h2> <p>We need several elements:</p> <ul> <li>A starting point in the problem/solution terrain.</li> <li>A way to collect and measure problems in the near space around us.</li> <li>A way to experiment with solutions cheaply and rapidly.</li> <li>A way to measure these experiments against our problems.</li> <li>A way to discard the failures and propagate the successes.</li> <li>A way to isolate layers so we can review and re-solve old problems.</li> </ul> <p>Let's apply the mechanical process to software design and see what we get. This will sound repetitive to readers of my blog.</p> <ul> <li>Starting point: identify a single interesting problem and make a minimal, plausible prototype. Time taken: 3-5 days maximum.</li> </ul> <ul> <li>Collecting and measuring problems: publish your prototype on github.com and ask people to play with it. Use it <strong>yourself</strong> and collect problems with it. Write these down as issues.</li> </ul> <ul> <li>Experimenting with solutions: pick out the most critical ones and figure out &quot;good enough&quot; solutions to these. Make patches and merge them.</li> </ul> <ul> <li>Measuring solutions against problems: try the results. You should always have executable, usable product that can be shipped if needed (even as a prototype).</li> </ul> <ul> <li>Discarding failures and propagating successes: if you don't like the solutions, revert the patches. If you like them, close the issue. Use the LGPL to ensure your successes get the widest trade with other projects.</li> </ul> <ul> <li>Isolating layers: use ZeroMQ to isolate layers so that you can throw away old pieces and start again without bringing your whole product into question.</li> </ul> <h2><span>Conclusions</span></h2> <p>Talent lets you move faster, and process gets you to the right <em>place</em>. The ideal process seems to be one based on highly incremental small steps, each step solving one identifiable problem with a &quot;good enough&quot; solution. Over time, the collection of small accurate solutions to real problems, and removal of mistakes, will give you a highly valuable product that people will love.</p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613568" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:23</guid>
				<title>Good, Cheap, and Fast - PC3</title>
				<link>http://hintjens.com/blog:23</link>
				<description>

&lt;p&gt;The Pedantic Code Construction Contract (PC3) is an evolution of the GitHub &lt;a href=&quot;http://help.github.com/send-pull-requests/&quot;&gt;Fork + Pull Model&lt;/a&gt;, and the &lt;a href=&quot;http://rfc.zeromq.org/spec:16&quot;&gt;ZeroMQ C4 process&lt;/a&gt;, aimed at providing an optimal collaboration model for commercial software projects. PC3 helps an organization build consistently good software, cheaply, and rapidly.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613568&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Thu, 29 Mar 2012 16:12:06 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>The Pedantic Code Construction Contract (PC3) is an evolution of the GitHub <a href="http://help.github.com/send-pull-requests/">Fork + Pull Model</a>, and the <a href="http://rfc.zeromq.org/spec:16">ZeroMQ C4 process</a>, aimed at providing an optimal collaboration model for commercial software projects. PC3 helps an organization build consistently good software, cheaply, and rapidly.</p> <h2><span>Language</span></h2> <p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in RFC 2119[<a href="javascript:;" class="bibcite" id="bibcite-411492-1-32309a" >1</a>].</p> <h2><span>Goals</span></h2> <p>PC3 is meant to provide an optimal collaboration model for commercial software projects. Broadly, PC3 helps an organization build consistently good software, cheaply, and rapidly. It has these specific goals:</p> <ul> <li>To maximize the scale of the community around a project, by reducing the friction for new Contributors and creating a scaled participation model with strong positive feedbacks;</li> </ul> <ul> <li>To relieve dependencies on key individuals by separating different skill sets so that there is a larger pool of competence in any required domain;</li> </ul> <ul> <li>To allow the project to develop faster and more accurately, by increasing the diversity of the decision making process;</li> </ul> <ul> <li>To support the natural life-cycle of project versions from experimental through to stable, by allowing safe experimentation, rapid failure, and isolation of stable code;</li> </ul> <ul> <li>To reduce the internal complexity of project repositories, thus making it easier for Contributors to participate and reducing the scope for error;</li> </ul> <ul> <li>To reduce the need for meetings, face-to-face presence, and timezone synchronization, by capturing knowledge more accurately.</li> </ul> <ul> <li>To optimize the efficiency of worker resources, by using on-time self-assignment instead of up-front task allocation.</li> </ul> <h2><span>Design</span></h2> <h3><span>Preliminaries</span></h3> <ul> <li>The project SHALL use the git distributed revision control system.</li> <li>The project SHALL be hosted on github.com or equivalent, herein called the &quot;Platform&quot;.</li> <li>The project SHALL use the Platform issue tracker.</li> <li>The project SHOULD have clearly documented guidelines for code style.</li> <li>A &quot;Contributor&quot; is a person who wishes to provide a patch, being a set of commits that solve some clearly identified problem.</li> <li>A &quot;Maintainer&quot; is a person who merge patches to the project. Maintainers are not developers; their job is to enforce process.</li> <li>A &quot;Reviewer&quot; is a person who reviews patches and who has deep familiarity with the code base.</li> <li>Contributors SHALL NOT have commit access to the repository unless they are also Maintainers.</li> <li>Maintainers SHALL have commit access to the repository.</li> <li>Reviewers SHALL NOT have commit access to the repository unless they are also Maintainers.</li> <li>Everyone, without distinction or discrimination, SHALL have an equal right to become a Contributor under the terms of this contract.</li> </ul> <h3><span>Patch Requirements</span></h3> <ul> <li>Maintainers, Contributors and Reviewers MUST have a Platform account and SHOULD use their real names or a well-known alias.</li> <li>A patch SHOULD be a minimal and accurate answer to exactly one identified and agreed problem.</li> <li>A patch MUST adhere to the code style guidelines of the project if these are defined.</li> <li>A patch MUST adhere to the &quot;Evolution of Public Contracts&quot; guidelines defined below.</li> <li>A patch MUST compile cleanly on at least the most important target Platforms.</li> <li>A &quot;Correct Patch&quot; is one that satisfies the above requirements.</li> </ul> <h3><span>Development Process</span></h3> <ul> <li>Change on the project SHALL be governed by the pattern of accurately identifying problems and applying minimal, accurate solutions to these problems.</li> <li>To initiate changes, a user SHALL log an issue on the project Platform issue tracker.</li> <li>The user SHOULD write the issue by describing the problem they face or observe.</li> <li>The user SHOULD seek consensus on the accuracy of their observation, and the value of solving the problem.</li> <li>Thus, the release history of the project SHALL be a list of meaningful issues logged and solved.</li> <li>To work on an issue, a Contributor SHALL fork the project repository and then work on their forked repository.</li> <li>To submit a patch, a Contributor SHALL create a Platform pull request back to the project.</li> <li>A Contributor SHALL NOT commit changes directly to the project.</li> <li>To discuss a patch, people MAY comment on the Platform pull request, on the commit, or elsewhere.</li> <li>To accept or reject a patch, a Maintainer SHALL use the Platform interface to merge the patch.</li> <li>Maintainers SHALL NOT accept their own patches.</li> <li>Maintainers SHALL NOT make value judgments on correct patches, this is handled by the optional Code Review Process.</li> <li>Maintainers SHOULD ask for improvements to incorrect patches and SHOULD reject incorrect patches if the Contributor does not respond constructively.</li> <li>Maintainers MAY commit changes to non-source documentation directly to the project.</li> </ul> <h3><span>Code Review Process</span></h3> <ul> <li>The project MAY use a code review process, particularly if it is a shipping project with non-trivial complexity.</li> <li>In code reviews are enabled for the project, Maintainers SHALL NOT merge a patch until a Reviewer has examined and approved the patch.</li> <li>If code reviews are not enabled for the project, Maintainers SHALL merge correct patches rapidly.</li> </ul> <h3><span>Creating Stable Releases</span></h3> <ul> <li>The project SHALL have one branch (&quot;master&quot;) that always holds the latest in-progress version and SHOULD always build.</li> <li>The project SHALL NOT use topic branches for any reason. Personal forks MAY use topic branches.</li> <li>To make a stable release someone SHALL fork the repository by copying it and thus become maintainer of this repository.</li> <li>Forking a project for stabilization MAY be done unilaterally and without agreement of project maintainers.</li> <li>Maintainers of the stabilization project SHALL maintain it through pull requests which MAY cherry-pick patches from the forked project.</li> <li>A patch to a repository declared &quot;stable&quot; SHALL be accompanied by a reproducible test case.</li> <li>A stabilization repository SHOULD progress through these phases: &quot;unstable&quot;, &quot;candidate&quot;, &quot;stable&quot;, and then &quot;legacy&quot;. That is, the default behavior of stabilization repositories is to die.</li> </ul> <h3><span>Evolution of Public Contracts</span></h3> <ul> <li>All Public Contracts (APIs or protocols) SHOULD be documented.</li> <li>All Public Contracts SHALL use Semantic Versioning[<a href="javascript:;" class="bibcite" id="bibcite-411492-2-96821a" >2</a>].</li> <li>All Public Contracts SHOULD have space for extensibility and experimentation.</li> <li>A patch that modifies a Public Contract SHOULD not break existing applications unless there is prior consensus on the value of doing this.</li> <li>A patch that introduces new features to a Public Contract SHOULD do so using new names.</li> <li>Old names SHOULD be deprecated in a systematic fashion by marking new names as &quot;experimental&quot; until they are stable, then marking the old names as &quot;deprecated&quot;.</li> <li>When sufficient time has passed, old deprecated names SHOULD be marked &quot;legacy&quot; and eventually removed.</li> <li>Old names SHALL NOT be reused by new features.</li> <li>When old names are removed, their implementations MUST provoke an exception (assertion) if used by applications.</li> </ul> <h3><span>Issue Format</span></h3> <ul> <li>One issue SHOULD address one single identifiable problem or a small set of tightly related problems.</li> <li>The issue title SHOULD state the observed problem in minimal fashion.</li> <li>The issue body SHOULD capture all relevant data in a minimal and accurate fashion.</li> <li>The issue body MAY propose solutions.</li> <li>Users SHALL NOT log feature requests, ideas, suggestions, or any solutions to problems that are not explicitly documented and provable.</li> </ul> <h3><span>Task and Role Assignment</span></h3> <ul> <li>All tasks and roles SHALL be self-assigned, based on individual judgement of the value of taking on a certain task or role.</li> </ul> <h2><span>References</span></h2> <div class="bibitems"> <div class="title">Bibliography</div> <div class="bibitem" id="bibitem-411492-1">1. &quot;Key words for use in RFCs to Indicate Requirement Levels&quot; - <a href="http://tools.ietf.org/html/rfc2119">ietf.org</a></div> <div class="bibitem" id="bibitem-411492-2">2. &quot;Semantic Versioning 2.0.0-rc.1&quot; - <a href="http://semver.org/">semver.org</a></div> </div> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613568" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
					<item>
				<guid>http://hintjens.com/blog:22</guid>
				<title>The Lazy Perfectionist and other Patterns</title>
				<link>http://hintjens.com/blog:22</link>
				<description>

&lt;p&gt;In this article I&#039;m presenting a series of patterns for success in software engineering. These patterns aim to capture the essence of what divides glorious success from tragic failure. They were described as &amp;quot;&lt;em&gt;religious maniacal dogma&lt;/em&gt;&amp;quot; by a manager, and &amp;quot;&lt;em&gt;anything else would be fucking insane&lt;/em&gt;&amp;quot; by a colleague, in a single day. For me, they are science, the results of decades of trial by error. Treat the Lazy Perfectionist and others as tools to use, sharpen, and throw away if something better comes along.&lt;/p&gt;
&lt;p&gt;by &lt;span class=&quot;printuser avatarhover&quot;&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;&lt;img class=&quot;small&quot; src=&quot;http://www.wikidot.com/avatar.php?userid=99&amp;amp;amp;size=small&amp;amp;amp;timestamp=1570613568&quot; alt=&quot;pieterh&quot; style=&quot;background-image:url(http://www.wikidot.com/userkarma.php?u=99)&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.wikidot.com/user:info/pieterh&quot;  &gt;pieterh&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Thu, 01 Mar 2012 20:00:02 +0000</pubDate>
												<content:encoded>
					<![CDATA[
						 <p>In this article I'm presenting a series of patterns for success in software engineering. These patterns aim to capture the essence of what divides glorious success from tragic failure. They were described as &quot;<em>religious maniacal dogma</em>&quot; by a manager, and &quot;<em>anything else would be fucking insane</em>&quot; by a colleague, in a single day. For me, they are science, the results of decades of trial by error. Treat the Lazy Perfectionist and others as tools to use, sharpen, and throw away if something better comes along.</p> <table style="margin:0; padding:0"> <tr> <td style="margin:0; padding:0"> <div id="toc"> <div id="toc-action-bar"><a href="javascript:;" >Fold</a><a style="display: none" href="javascript:;" >Unfold</a></div> <div class="title">Table of Contents</div> <div id="toc-list"> <div style="margin-left: 2em;"><a href="#toc0">The Lazy Perfectionist</a></div> <div style="margin-left: 2em;"><a href="#toc1">The Benevolent Tyrant</a></div> <div style="margin-left: 2em;"><a href="#toc2">The Earth and Sky</a></div> <div style="margin-left: 2em;"><a href="#toc3">The Happy Failure</a></div> <div style="margin-left: 2em;"><a href="#toc4">The Open Door</a></div> <div style="margin-left: 2em;"><a href="#toc5">The Laughing Clown</a></div> <div style="margin-left: 2em;"><a href="#toc6">The Mindful General</a></div> <div style="margin-left: 2em;"><a href="#toc7">The Social Engineer</a></div> <div style="margin-left: 2em;"><a href="#toc8">The Constant Gardener</a></div> <div style="margin-left: 2em;"><a href="#toc9">The Rolling Stone</a></div> <div style="margin-left: 2em;"><a href="#toc10">The Pirate Gang</a></div> <div style="margin-left: 2em;"><a href="#toc11">The Flash Mob</a></div> <div style="margin-left: 2em;"><a href="#toc12">The Canary Watcher</a></div> <div style="margin-left: 2em;"><a href="#toc13">The Hangman</a></div> <div style="margin-left: 2em;"><a href="#toc14">The Historian</a></div> <div style="margin-left: 2em;"><a href="#toc15">The Provocateur</a></div> <div style="margin-left: 2em;"><a href="#toc16">The Mystic</a></div> </div> </div> </td> </tr> </table> <h2><span>The Lazy Perfectionist</span></h2> <p><em>Never design anything that's not a precise minimal answer to a problem we can identify and have to solve.</em> &#8212; Pieter Hintjens</p> <p>The Lazy Perfectionist spends his idle time observing others and identifying problems that are worth solving. He looks for agreement on those problems, always asking, &quot;what is the <em>real</em> problem&quot;. Then he moves, precisely and minimally, to build, or get others to build, a usable answer to one problem. He uses, or gets others to use those solutions. And he repeats this until there are no problems left to solve, or time or money runs out.</p> <h2><span>The Benevolent Tyrant</span></h2> <p><em>The control of a large force is the same principle as the control of a few men: it is merely a question of dividing up their numbers.</em> &#8212; Sun Tzu</p> <p>The Benevolent Tyrant divides large problems into smaller ones and throws them at groups to focus on. He brokers contracts between these groups, in the form of APIs and unprotocols. The Benevolent Tyrant constructs a supply chain that starts with problems, and results in usable solutions. He is ruthless about how the supply chain works, but does not tell people on what to work, nor how to do their work.</p> <h2><span>The Earth and Sky</span></h2> <p><em>The ideal team consists of two sides: one writing code, and one providing feedback.</em> &#8212; Pieter Hintjens</p> <p>The Earth and Sky work together as a whole, in close proximity, but they communicate formally through an issue tracking. Sky seeks out problems, from others and from their own use of the product, and feeds these to Earth. Earth rapidly answers with testable solutions. Earth and Sky can work through dozens of issues in a day. Sky talks to other users, and Earth talks to other developers. Earth and Sky may be two people, or two small groups.</p> <h2><span>The Happy Failure</span></h2> <p><em>To succeed you must learn to fail rapidly, cheaply, and often.</em> &#8212; Pieter Hintjens</p> <p>The Happy Failure embraces failure as the only real way to learn. He focuses on reducing the cost of failure, and documenting failures so that everyone can learn from them. He does not over-specify functionality, stays away from upfront documentation, does not use test-driven development. All of these make it harder, and more costly to fail.</p> <h2><span>The Open Door</span></h2> <p><em>The accuracy of knowledge comes from diversity.</em> &#8212; Pieter Hintjens</p> <p>The Open Door accepts contributions from almost anyone. He does not argue quality or direction, instead allowing others to argue that and so get more engaged. He calculates that even a troll will bring more diverse opinion to the group. He lets the group form its opinion about what goes into stable code, and he enforces this opinion with help of a Benevolent Tyrant.</p> <h2><span>The Laughing Clown</span></h2> <p><em>Perfection precludes participation.</em> &#8212; Pieter Hintjens</p> <p>The Laughing Clown, often acting as the Happy Failure, makes no claim to high competence. Instead his antics and bumbling attempts provoke others into rescuing him from his own tragedy. Somehow however, he always identifies the right problems to solve. People are so busy proving him wrong they don't realize they're doing valuable work.</p> <h2><span>The Mindful General</span></h2> <p><em>Make no plans. Set goals, develop strategies and tactics.</em> &#8212; Pieter Hintjens</p> <p>The Mindful General operates in unknown territory, solving problems that are hidden until they are nearby. Thus he makes no plans, but seeks opportunities, then exploits them rapidly and accurately. He develops tactics and strategies in the field, and teaches these to his men so they can move independently, and together.</p> <h2><span>The Social Engineer</span></h2> <p><em>If you know the enemy and know yourself, you need not fear the result of a hundred battles.</em> &#8212; Sun Tzu</p> <p>The Social Engineer reads the hearts and minds of those he works with and for. He asks, of everyone, &quot;what makes this person angry, insecure, argumentative, calm, happy?&quot; He studies their moods and disposition. With this knowledge he can encourage those who are useful, and discourage those who are not. The Social Engineer never acts on his own emotions.</p> <h2><span>The Constant Gardener</span></h2> <p><em>Do not repeat the tactics which gained you one victory, but let your methods be regulated by the infinite variety of circumstances.</em> &#8212; Sun Tzu</p> <p>The Constant Gardener grows a process from a small seed, step by step as more people come into the project. He makes every change for a precise reason, with agreement from everyone. He never imposes a process from above but will let others come to consensus, then he will enforce that consensus. In this way everyone owns the process together and by owning it, they are attached to it.</p> <h2><span>The Rolling Stone</span></h2> <p><em>After crossing a river, you should get far away from it.</em> &#8212; Sun Tzu</p> <p>The Rolling Stone accepts his own mortality and transience. He has no attachment to his past work. He accepts that all that we make is destined for the trash can, it is just a matter of time. With precise, minimal investments, he can move rapidly away from the past and stay focused on the present and near future. Above all he has no ego and no pride to be hurt by the actions of others.</p> <h2><span>The Pirate Gang</span></h2> <p><em>Code, like all knowledge, works best as collective &#8212; not private &#8212; property.</em> &#8212; Pieter Hintjens</p> <p>The Pirate Gang organize freely around problems. They accept authority insofar as it provides goals and resources. The Pirate Gang own and share all they make: every work is fully remixable by others in the Pirate Gang. They move rapidly as new problems emerge, and are quick to abandon old solutions if they stop being relevant. No persons or groups can monopolize any part of the supply-chain.</p> <h2><span>The Flash Mob</span></h2> <p><em>Water shapes its course according to the nature of the ground over which it flows.</em> &#8212; Sun Tzu</p> <p>The Flash Mob comes together in space and time as needed, then disperses as soon as they can. Physical closeness is essential for high-bandwidth communications. But over time it creates technical ghettos, where Earth gets separated from Sky. The Flash Mob tends to collect a lot of frequent flier miles.</p> <h2><span>The Canary Watcher</span></h2> <p><em>Pain is not, generally, a Good Sign.</em> &#8212; Pieter Hintjens</p> <p>The Canary Watcher measures the quality of an organization by the their own pain level, and the observed pain levels of those he works with. He brings new participants into existing organizations so they can express the raw pain of the innocent. He may use alcohol to get others to verbalize their pain points. He asks others, and himself, &quot;are you happy in this process, and if not, why not?&quot; When an organization causes pain in himself or others, he treats that as a problem to be fixed. People should feel joy in their work.</p> <h2><span>The Hangman</span></h2> <p><em>Never interrupt others when they are making mistakes.</em> &#8212; Pieter Hintjens</p> <p>The Hangman knows that we learn only by making mistakes, and he gives others copious rope with which to learn. He only pulls the rope gently, when it's time. A little tug to remind the other of their precarious position. Allowing others to learn by failure gives the good reason to stay, and the bad excuse to leave. The Hangman is endlessly patient, because there is no shortcut to the learning process.</p> <h2><span>The Historian</span></h2> <p><em>The public record may be tedious, but it's the only way to prevent collusion.</em> &#8212; Pieter Hintjens</p> <p>The Historian forces discussion into the public view, to prevent collusion to own areas of work. The Pirate Gang depends on full and equal communications that do not depend on momentary presence. No-one really reads the archives, but the simply possibility stops most abuses. The Historian encourages the right tool for the job: email for transient discussions, IRC for chatter, wikis for knowledge, issue tracking for recording opportunities.</p> <h2><span>The Provocateur</span></h2> <p><em>When a man knows he is to be hanged in a fortnight, it concentrates his mind wonderfully.</em> &#8212; Samuel Johnson</p> <p>The Provocateur creates deadlines, enemies, and the occasional impossibility. Teams work best when they don't have time for the crap. Deadlines bring people together and focus the collective mind. An external enemy can move a passive team into action. The Provocateur never takes the deadline too seriously. The product is <em>always</em> ready to ship. But he gently reminds the team of the stakes: fail, and we all look for other jobs.</p> <h2><span>The Mystic</span></h2> <p><em>When people argue or complain, just write them a Sun Tzu quotation</em> &#8212; Mikko Koppanen</p> <p>The Mystic never argues directly. He knows that to argue with an emotional person only creates more emotion. Instead he side-steps the discussion. It's hard to be angry at a Chinese general, especially when he has been dead for 2,400 years. The Mystic will act as the Hangman when people insist on the right to get it wrong.</p> <p><em>This article is an extract from Chapter 6 of the ZeroMQ book, on community building. If you like this, buy the book :-)</em></p> <p>by <span class="printuser avatarhover"><a href="http://www.wikidot.com/user:info/pieterh" ><img class="small" src="http://www.wikidot.com/avatar.php?userid=99&amp;amp;size=small&amp;amp;timestamp=1570613568" alt="pieterh" style="background-image:url(http://www.wikidot.com/userkarma.php?u=99)" /></a><a href="http://www.wikidot.com/user:info/pieterh" >pieterh</a></span></p> 
				 	]]>
				</content:encoded>							</item>
				</channel>
</rss>